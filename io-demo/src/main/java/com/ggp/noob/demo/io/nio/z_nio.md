# 简介

​	IO我们一般认为是New I/O（也是官方的叫法），因为它是相对于老的I/O类库新增的（其实在JDK 1.4中就已经被引入了，但这个名词还会继续用很久，即使它们在现在看来已经是“旧”的了，所以也提示我们在命名时，需要好好考虑），做了很大的改变。但民间跟多人称之为Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。而下文中的NIO，不是指整个新的I/O库，而是非阻塞I/O。

​	NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。

  新增的着两种通道都支持阻塞和非阻塞两种模式。

  阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。

  对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。

# channel

	+ CPU在执行用户程序时遇到I/O请求，根据用户的I/O请求生成通道程序（也可以是事先编好的）。放到内存中，并把该通道程序首地址放入CAW中。
	+ CPU执行“启动I/O”指令，启动通道工作。
	+ 通道接收“启动I/O”指令信号，从CAW（记录下一条通道指令存放的地址）中取出通道程序首地址，并根据此地址取出通道程序的第一条指令，放入CCW（记录正在执行的通道指令）中；同时向CPU发回答信号，通知“启动I/O”指令完成完毕，CPU可继续执行。
	+ .与此同时，通道开始执行通道程序，进行物理I/O操作。当执行完一条指令后，如果还有下一条指令则继续执行；否则表示传输完成，同时自行停止，通知CPU转去处理通道结束事件，并从CCW中得到有关通道状态。

   **如此一来，主处理器只要发出一个I/O操作命令，剩下的工作完全由通道负责。I/O操作结束后，I/O通道会发出一个中断请求，表示相应操作已完成。**

# Buffer

​	Buffer是一个对象，包含一些要写入或者读出的数据。

  在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

  缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。

  具体的缓存区有这些：ByteBuffer、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。

# selector

​	Selector是Java  NIO 编程的基础。

​    Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

  一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。



# NIO-Server

1. 打开ServerSocketChannel，监听客户端连接
2. 绑定监听端口，设置连接为非阻塞模式
3. 创建Reactor线程，创建多路复用器并启动线程
4. 将ServerSocketChannel注册到Reactor线程中的Selector上，监听ACCEPT事件
5. Selector轮询准备就绪的key
6.  Selector监听到新的客户端接入，处理新的接入请求，完成TCP三次握手，创建物理链路
7. 设置客户端链路为非阻塞模式
8. 将新接入的客户端连接注册到Reactor线程的Selector上，监听读操作，读取客户端发送的网络消息
9. 异步读取客户端消息到缓冲区（channel自己读）
10. 对Buffer编解码，处理解码后的消息
11. 将应答消息编码为Buffer，调用SocketChannel的write将消息异步发送给客户端





