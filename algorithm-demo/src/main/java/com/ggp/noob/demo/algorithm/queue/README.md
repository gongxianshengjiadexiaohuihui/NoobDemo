# 如何理解“队列”？
    队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。
    先进者先出，这就是典型的“队列”。我们知道，栈只支持两个基本操作：入栈 push()和出栈 pop()。
    队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：
    入队 enqueue()，放一个数据到队列尾部；
    出队 dequeue()，从队列头部取一个元素。
    所以，队列跟栈一样，也是一种操作受限的线性表数据结构。
# 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？
    我们一般有两种处理策略。
    第一种是非阻塞的处理方式，直接拒绝任务请求；
    另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。
    那如何存储排队的请求呢？我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。
    这两种实现方式对于排队请求又有什么区别呢？基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
    而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。
# 应用场景
    队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。
# 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？
    分布式应用中的消息队列
# 如何实现无锁并发队列
    考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。
 