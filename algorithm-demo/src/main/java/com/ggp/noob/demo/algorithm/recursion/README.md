# 递归解释
    递是传递，归是归还，先传递到最初值(终止条件)，然后在换回来。
# 递归需要满足三个条件
* 一个问题的解可以分解为几个子问题的解
* 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
* 存在递归终止条件
# 走台阶问题
    假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？
    如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？
   实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。
   所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。
   用公式表示就是：f(n) = f(n-1)+f(n-2),递归终止条件就是 f(1)=1，f(2)=2
# 递归代码要警惕堆栈溢出
* 限制递归调用的最大深度
# 递归代码要警惕重复计算
    无论是走楼梯还是斐波那契数列，只要有两个以上的分支都会存在重复计算问题，解决方案加缓存（空间换时间，考虑有淘汰策略）
# 转换为非递归
    递归代码 = 通项公式 + 初始条件。因此是可以转换成非递归代码的。
    递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。
    所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。